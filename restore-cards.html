<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Récupération des flashcards</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.5;
    }
    h1 {
      color: #4338ca;
      margin-bottom: 1em;
    }
    button {
      background-color: #4338ca;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      margin: 10px 0;
    }
    button:hover {
      background-color: #3730a3;
    }
    pre {
      background-color: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
      overflow: auto;
      margin-top: 15px;
    }
    .card-container {
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
    }
    .card {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 10px;
      background-color: #f8fafc;
    }
    .card-front {
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #e2e8f0;
      padding-bottom: 8px;
    }
    .card-back {
      color: #4b5563;
    }
    .key-value {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 14px;
    }
    .status {
      margin: 20px 0;
      padding: 15px;
      border-radius: 8px;
    }
    .success {
      background-color: #dcfce7;
      color: #166534;
    }
    .warning {
      background-color: #fef9c3;
      color: #854d0e;
    }
    .error {
      background-color: #fee2e2;
      color: #b91c1c;
    }
  </style>
</head>
<body>
  <h1>Outil de récupération des flashcards</h1>
  
  <div id="status"></div>
  
  <button id="analyze">Analyser le localStorage</button>
  <button id="recover">Récupérer les cartes</button>
  <button id="clear-segments">Nettoyer les segments inutiles</button>
  
  <pre id="output">Les résultats s'afficheront ici...</pre>
  
  <h2>Cartes récupérées</h2>
  <div id="cards-container" class="card-container"></div>
  
  <script>
    // Clés de stockage
    const CARDS_KEY = 'cds-flashcard-cards';
    
    // Fonction utilitaire pour imprimer les clés et valeurs du localStorage
    function dumpLocalStorage() {
      let output = '=== CONTENU DU LOCALSTORAGE ===\n';
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        try {
          // Essayons de l'obtenir en format JSON
          let value = localStorage.getItem(key);
          // Si la valeur est longue, on ne montre que le début
          if (value && value.length > 1000) {
            value = value.substring(0, 200) + '... [tronqué]';
          }
          output += `${key}: ${value}\n`;
        } catch (e) {
          output += `Erreur lors de la lecture de la clé ${key}: ${e}\n`;
        }
      }
      output += '============================\n';
      return output;
    }
    
    // Fonction pour montrer des statistiques sur l'utilisation du localStorage
    function getStorageStats() {
      let totalSize = 0;
      let cardKeys = [];
      let deckKeys = [];
      let themeKeys = [];
      let otherKeys = [];
    
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key) || '';
        const size = (key.length + value.length) * 2; // Approximation en bytes (UTF-16)
        
        totalSize += size;
        
        if (key.includes('flashcard') || key.includes('card')) {
          cardKeys.push({ key, size: Math.round(size / 1024) });
        } else if (key.includes('deck')) {
          deckKeys.push({ key, size: Math.round(size / 1024) });
        } else if (key.includes('theme')) {
          themeKeys.push({ key, size: Math.round(size / 1024) });
        } else {
          otherKeys.push({ key, size: Math.round(size / 1024) });
        }
      }
      
      let output = '=== STATISTIQUES DU STOCKAGE ===\n';
      output += `Taille totale: ${Math.round(totalSize / 1024)} KB (sur 5120 KB max)\n`;
      output += `Clés liées aux cartes: ${cardKeys.length}\n`;
      output += `Détail des clés de cartes: ${JSON.stringify(cardKeys, null, 2)}\n`;
      output += `Clés liées aux decks: ${deckKeys.length}\n`;
      output += `Clés liées aux thèmes: ${themeKeys.length}\n`;
      output += `Autres clés: ${otherKeys.length}\n`;
      output += '==============================\n';
      return output;
    }
    
    // Fonction pour tenter de récupérer toutes les cartes
    function recoverCards() {
      // Liste pour stocker toutes les cartes récupérées
      let allCards = [];
      let output = '';
      
      // 1. Essayons d'abord la clé principale
      try {
        const mainData = localStorage.getItem(CARDS_KEY);
        if (mainData) {
          try {
            const cards = JSON.parse(mainData);
            if (Array.isArray(cards) && cards.length > 0) {
              output += `Trouvé ${cards.length} cartes dans la clé principale\n`;
              allCards = allCards.concat(cards);
            }
          } catch (e) {
            output += `Erreur de parsing de la clé principale: ${e}\n`;
          }
        }
      } catch (e) {
        output += `Erreur lors de la récupération de la clé principale: ${e}\n`;
      }
      
      // 2. Cherchons ensuite les segments
      const segmentPrefixes = ['_s', '_segment_'];
      
      segmentPrefixes.forEach(prefix => {
        for (let i = 0; i < 100; i++) {
          const segmentKey = `${CARDS_KEY}${prefix}${i}`;
          try {
            const segmentData = localStorage.getItem(segmentKey);
            if (!segmentData) continue;
            
            try {
              // Essayer de parser chaque segment
              let dataString = segmentData;
              
              // Si le segment est compressé, tenter de récupérer les données brutes
              if (segmentData.startsWith('C:') || segmentData.startsWith('R:')) {
                dataString = segmentData.substring(2); // Enlever le préfixe
              }
              
              const cards = JSON.parse(dataString);
              if (Array.isArray(cards) && cards.length > 0) {
                output += `Trouvé ${cards.length} cartes dans ${segmentKey}\n`;
                allCards = allCards.concat(cards);
              }
            } catch (parseError) {
              output += `Erreur de parsing pour ${segmentKey}: ${parseError}\n`;
            }
          } catch (e) {
            // Ignorer les erreurs de récupération
          }
        }
      });
      
      // 3. Recherche des clés de sauvegarde
      const backupKeys = [
        `${CARDS_KEY}_backup`,
        `${CARDS_KEY}_legacy`,
        `${CARDS_KEY}_recovered`
      ];
      
      backupKeys.forEach(backupKey => {
        try {
          const backupData = localStorage.getItem(backupKey);
          if (!backupData) return;
          
          try {
            const cards = JSON.parse(backupData);
            if (Array.isArray(cards) && cards.length > 0) {
              output += `Trouvé ${cards.length} cartes dans ${backupKey}\n`;
              allCards = allCards.concat(cards);
            }
          } catch (parseError) {
            output += `Erreur de parsing pour ${backupKey}: ${parseError}\n`;
          }
        } catch (e) {
          // Ignorer les erreurs de récupération
        }
      });
      
      // 4. Déduplication des cartes par ID
      const uniqueCards = {};
      allCards.forEach(card => {
        if (card && card.id) {
          uniqueCards[card.id] = card;
        }
      });
      
      const finalCards = Object.values(uniqueCards);
      
      output += `=== RÉSULTAT DE LA RÉCUPÉRATION ===\n`;
      output += `Total de cartes récupérées: ${finalCards.length}\n`;
      
      // 5. Sauvegarder les cartes récupérées
      if (finalCards.length > 0) {
        try {
          // D'abord, sauvegardons une copie de sécurité
          localStorage.setItem(`${CARDS_KEY}_emergency_backup`, JSON.stringify(finalCards));
          output += `Sauvegarde d'urgence créée avec succès\n`;
          
          // Maintenant, restaurons les cartes dans la clé principale
          localStorage.setItem(CARDS_KEY, JSON.stringify(finalCards));
          output += `Cartes restaurées avec succès dans la clé principale\n`;
          
          document.getElementById('status').innerHTML = 
            `<div class="status success">✅ ${finalCards.length} cartes ont été récupérées et restaurées avec succès!</div>`;
          
          return { cards: finalCards, output };
        } catch (e) {
          output += `Erreur lors de la sauvegarde des cartes récupérées: ${e}\n`;
          document.getElementById('status').innerHTML = 
            `<div class="status error">❌ Erreur lors de la sauvegarde: ${e}</div>`;
        }
      } else {
        document.getElementById('status').innerHTML = 
          `<div class="status warning">⚠️ Aucune carte trouvée à récupérer.</div>`;
      }
      
      return { cards: finalCards, output };
    }
    
    // Fonction pour nettoyer les segments inutiles
    function clearSegments() {
      const segmentPrefixes = ['_s', '_segment_'];
      let output = '';
      let count = 0;
      
      segmentPrefixes.forEach(prefix => {
        for (let i = 0; i < 100; i++) {
          const segmentKey = `${CARDS_KEY}${prefix}${i}`;
          try {
            if (localStorage.getItem(segmentKey) !== null) {
              localStorage.removeItem(segmentKey);
              count++;
              output += `Segment supprimé: ${segmentKey}\n`;
            }
          } catch (e) {
            output += `Erreur lors de la suppression de ${segmentKey}: ${e}\n`;
          }
        }
      });
      
      output += `Total de segments nettoyés: ${count}\n`;
      
      if (count > 0) {
        document.getElementById('status').innerHTML = 
          `<div class="status success">✅ ${count} segments ont été nettoyés avec succès!</div>`;
      } else {
        document.getElementById('status').innerHTML = 
          `<div class="status warning">ℹ️ Aucun segment à nettoyer.</div>`;
      }
      
      return output;
    }
    
    // Fonction pour afficher les cartes récupérées
    function displayCards(cards) {
      const container = document.getElementById('cards-container');
      container.innerHTML = '';
      
      if (cards.length === 0) {
        container.innerHTML = '<p>Aucune carte à afficher.</p>';
        return;
      }
      
      cards.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        
        const cardFront = document.createElement('div');
        cardFront.className = 'card-front';
        cardFront.textContent = card.front.text.substring(0, 50) + (card.front.text.length > 50 ? '...' : '');
        
        const cardBack = document.createElement('div');
        cardBack.className = 'card-back';
        cardBack.textContent = card.back.text.substring(0, 50) + (card.back.text.length > 50 ? '...' : '');
        
        cardElement.appendChild(cardFront);
        cardElement.appendChild(cardBack);
        
        container.appendChild(cardElement);
      });
    }
    
    // Écouteurs d'événements
    document.getElementById('analyze').addEventListener('click', function() {
      const outputElement = document.getElementById('output');
      outputElement.textContent = getStorageStats() + '\n' + dumpLocalStorage();
    });
    
    document.getElementById('recover').addEventListener('click', function() {
      const outputElement = document.getElementById('output');
      const result = recoverCards();
      outputElement.textContent = result.output;
      displayCards(result.cards);
    });
    
    document.getElementById('clear-segments').addEventListener('click', function() {
      const outputElement = document.getElementById('output');
      outputElement.textContent = clearSegments();
    });
  </script>
</body>
</html>